load_lib common.exp


proc arch-of-file {file} {
    lindex [split $file "-"] 0
}

proc abi-of-file {file} {
    lindex [split $file "-"] 2
}

proc tripple-of-file {file} {
    join [lrange [split $file "-"] 0 end-1] "-"
}


proc get-log {} {
    global logfile
    set fd [open $logfile]
    set data [read $fd]
    close $fd
    return $data
}

proc assert-non-zero {result file test} {
    if {$result == 0} {
        fail "$test in $file"
    } else {
        pass "$test in $file"
    }
}

proc assert-zero {result file test} {
    if {$result == 0} {
        pass "$test in $file"
    } else {
        fail "$test in $file"
    }
}

proc collect-matching {file pattern} {
    set fd [open "$file.out"]
    set output [read $fd]
    close $fd
    return [regexp -inline -all -- $pattern $output]
}


proc non-zero-matches {file pattern test} {
    set got [collect-matching $file $pattern]
    set matches [llength $got]
    assert-non-zero $matches $file $test
}

proc zero-matches {file pattern test} {
    set got [collect-matching $file $pattern]
    set matches [llength $got]
    assert-zero $matches $file $test
}

proc with-exit-code {name opts expected expected_status} {
    set status 0
    if {[catch {uplevel 0 exec bap $opts >& output.out} results options]} {
        set details [dict get $options -errorcode]
        if {[lindex $details 0] eq "CHILDSTATUS"} {
            set status [lindex $details 2]
        } else {
            # Some other error; regenerate it to let caller handle
            return -options $options -level 0 $results
        }
    }
    if {$status == $expected_status} {
        pass "got the expected exit status for the $name"
    } else {
        fail "got a wrong exit status for the $name"
    }
    non-zero-matches output "$expected.*" "got the right message for the $name"
    exec rm -f output.out
}


# `foreach-binary {file pattern} {expectations}` spawns bap with `-d`
# option on each binary in the test suite that matches with the
# `pattern`, and pass expectations to `expect`. The name passed as a
# `file` argument is bound to the filename.
proc foreach-binary {nampat command expectations} {
    foreach file [find "bin" [lindex $nampat 1]] {
        uplevel 1 set [lindex $nampat 0] $file
        uplevel 1 spawn $command "--" "$file"
        uplevel 1 expect [list $expectations]
    }
}


#escape all non-word characters
#the & will be substituted by whatever was matched in the expression
proc escape {str} {
    regsub -all {\W} $str {\\&}
}


proc new_match {file format extra_opts expectations} {
    set opts [subst { "--dump=$format:$file.out" "$extra_opts" } ]
    set opts [join $opts " "]
    eval exec bap $file $opts
    set matched false
    foreach {pat act} $expectations {
        if {$pat == "default"} {
            continue
        } else {
            set got [collect-matching $file $pat]
            set matches [llength $got]
            if { $matches != 0} {
                set matched true
                uplevel 1 $act
            }
        }
    }
    if {$matched == false} {
        foreach {pat act} $expectations {
            if {$pat == "default"} {
                uplevel 1 $act
            }
        }
    }
    exec rm "$file.out"
}

proc base_match {file patterns test format extra_opts escaped } {
    set opts [subst { "--dump=$format:$file.out" "$extra_opts" } ]
    set opts [join $opts " "]
    eval exec bap $file $opts
    foreach pat $patterns {
        if {$escaped == "true"} {
            set line [escape $pat]
        } else {
            set line $pat
        }
        non-zero-matches $file $line "$test for $pat"
    }
   exec rm "$file.out"
}

# `match {file patternS testname format extra-options}
# runs bap and dumps output in the specified format. Then
# for each pattern from the LIST of patterns match the output
# with this pattern.
proc match {file patterns test {format "bir" } {extra_opts ""} } {
    base_match $file $patterns $test $format $extra_opts "false"
}

proc find_string {file string test {format "bir" } {extra_opts ""} } {
    base_match $file [subst { $string }] $test $format $extra_opts "true"
}

# find_strings {file strings testname format extra-options} - the same
# as match above, but search for the exact strings.
proc find_strings {file strings test {format "bir" } {extra_opts ""} } {
    base_match $file $strings $test $format $extra_opts "true"
}
